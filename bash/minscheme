#!/bin/bash

: <<'COMMENT'
# Data structure

Arenas are used to store data in referenceable form.

Value arena is one dimentional array in the following form.

( type1 x1 y1 type2 x2 y2 ... )

Each three consecutive data represents one value. Any value appears in the
program is stored in the arena and always referenced by its index in the
value arena. 0 represents the first data, 3 does the second data, and so on.
A type is one of the following: nil, bool, int, pair, symbol, func, quote .
A value of each type has the following form.

- nil "" ""
- bool #t ""
- int 100 ""
- pair 6 9
- symbol print ""
- func <func> ""
- quote 3 ""

<func> is a stringified bash script. It assumes two inputs $env and $val and
returns the resulting environment and value.

Env arena is one dimentional array in the following form. Any environment
appears in the program are referenced by its index in the env arena.

( next1 name1 value1 next2 name2 value2 ... )

name is a symbol string. next and value are pointers to the next item in the
linked list and the value for the symbol.

# Function calls
Using dynamic scope and eval, function return values can be emulated.
Functions typically end with eval to set return values. Example:
  add () {
    local a=$1 b=$2
    shift 2
    local res=$(( $a + $b ))
    eval "$1='$res'"
  }
  main () {
    local x
    add 1 2 x
    echo $x   # 3
  }
To use this technique, it's important that variables have unique names. In the
above example if we substitute a with x, the program will output nothing.
To ensure variable name uniqueness, a wrapper named call is used. call
generates unique id and use it in place of return values on calling wrapped
function, and forwards the results. call should be used whenever return values
are used. Example:
  fact () {
    local n=$1 res
    shift 1
    if [[ $n -eq 0 ]]; then
        res=1
    else
        call fact $(( $n - 1 )) res
        res=$(( $n * $res ))
    fi
    $returns res
  }
  call fact 10 res
  echo $res

Here, $returns is a shorthand for eval "$1='$res'".
COMMENT

declare code="$(cat $1))"

MAX_CALL=5000
call_index=0
call () {
    [[ $call_index -lt $MAX_CALL ]] || die "call_index >= $MAX_CALL"
    # use long name not to collide with return value names
    local call_variable_name="call_variable$(( call_index += 1 ))"
    local call_all_args=( "$@" )
    local call_real_name="${call_all_args[$(( $# - 1 ))]}"
    call_all_args[$(( $# - 1 ))]=$call_variable_name
    "${call_all_args[@]}"
    eval "$call_real_name='${!call_variable_name}'" || die "call"
}
call2 () {
    [[ $call_index -lt $MAX_CALL ]] || die "call_index >= $MAX_CALL"
    local call_variable_name1="call_variable$(( call_index += 1 ))"
    local call_variable_name2="call_variable$(( call_index += 1 ))"
    local call_all_args=( "$@" )
    local call_real_name1="${call_all_args[$(( $# - 2 ))]}"
    local call_real_name2="${call_all_args[$(( $# - 1 ))]}"
    call_all_args[$(( $# - 2 ))]=$call_variable_name1
    call_all_args[$(( $# - 1 ))]=$call_variable_name2
    "${call_all_args[@]}"
    eval "
        $call_real_name1='${!call_variable_name1}'
        $call_real_name2='${!call_variable_name2}'
    " || die "call2"
}
call3 () {
    [[ $call_index -lt $MAX_CALL ]] || die "call_index >= $MAX_CALL"
    local call_variable_name1="call_variable$(( call_index += 1 ))"
    local call_variable_name2="call_variable$(( call_index += 1 ))"
    local call_variable_name3="call_variable$(( call_index += 1 ))"
    local call_all_args=( "$@" )
    local call_real_name1="${call_all_args[$(( $# - 3 ))]}"
    local call_real_name2="${call_all_args[$(( $# - 2 ))]}"
    local call_real_name3="${call_all_args[$(( $# - 1 ))]}"
    call_all_args[$(( $# - 3 ))]=$call_variable_name1
    call_all_args[$(( $# - 2 ))]=$call_variable_name2
    call_all_args[$(( $# - 1 ))]=$call_variable_name3
    "${call_all_args[@]}"
    eval "
        $call_real_name1='${!call_variable_name1}'
        $call_real_name2='${!call_variable_name2}'
        $call_real_name3='${!call_variable_name3}'
    " || die "call3"
}

next () {
    local x

    call peek x
    code="${code:1}"

    $returns x
}
peek () {
    local x="${code:0:1}" 
    [[ $x == "'" ]] && x='`' # not to mess up eval
    $returns x
}
skip () {
    local x
    [[ -z "$code" ]] && return

    call peek x
    if [[ "$x" == " " ]] || [[ "$x" == $'\n' ]]; then
        next _
        skip
    fi
}
token () {
    local x y
    
    skip
    call next x
    case "$x" in
        "(" | ")" | '`')
            : ;;
        "#")
            call next x
            x="#${x}"
            ;;
        *)
            call peek y
            while [[ "$y" != ")" ]] && [[ "$y" != " " ]] && [[ "$y" != $'\n' ]]; do
                x="${x}${y}"

                call next _
                call peek y
            done
            ;;
    esac

    $returns x
}

VALARENA=("nil" "" "")
VALNIL=0

define () { eval "$1 () { call _$1 \"\$@\"; }"; }
define2 () { eval "$1 () { call2 _$1 \"\$@\"; }"; }
define3 () { eval "$1 () { call3 _$1 \"\$@\"; }"; }

define new_val
_new_val () {
    local kind="$1" first="$2" second="$3"
    shift 3
    local i=${#VALARENA[*]}
    VALARENA[$i]="$kind"
    VALARENA[$(( i + 1 ))]="$first"
    VALARENA[$(( i + 2 ))]="$second"

    $returns i
}
new_bool () {
    if [[ $1 -ne 0 ]]; then
        new_val "bool" "#t" _ "$2"
    else
        new_val "bool" "#f" _ "$2"
    fi
}
new_int () {
    new_val "int" "$1" _ "$2"
}
new_pair () {
    new_val "pair" $1 $2 $3
}
define2 must
_must () {
    local want_kind="$1" v="$2" kind first second
    shift 2
    valdestruct $v kind first second
    [[ $kind == $want_kind ]] || die "got $kind want $want_kind"
    $returns first second
}
define must_bool
_must_bool () {
    local res=1 x
    must "bool" $1 x _
    shift
    [[ $x == "#f" ]] && res=0
    $returns res
}
define must_int
_must_int () {
    local x
    must "int" $1 x _
    shift
    $returns x
}
define2 must_pair
_must_pair () {
    local x y
    must "pair" $1 x y
    shift
    $returns x y
}
define must_func
_must_func () {
    local x
    valdestruct $1 a b c
    must "func" "$1" x _
    shift
    $returns x
}
define3 valdestruct
_valdestruct () {
    local x=$1
    shift
    local kind="${VALARENA[$(( $x + 0 ))]}"
    local first="${VALARENA[$(( $x + 1 ))]}"
    local second="${VALARENA[$(( $x + 2 ))]}"

    $returns kind first second
}
valshow () {
    local nonewline="$2" kind first second
    valdestruct "$1" kind first second
    case "$kind" in
        "nil")
            echo -n nil;;
        "bool")
            echo -n "$first";;
        "int")
            echo -n "$first";;
        "pair")
            echo -n "( "
            valshow "$first" 1
            echo -n " . "
            valshow "$second" 1
            echo -n " )";;
        "quote")
            echo -n "'"
            valshow "$first" 1;;
        "symbol")
            echo -n "$first";;
        "func")
            echo -n "<func>";;
    esac
    [[ -z "$nonewline" ]] && echo
}
list () {
    local x y res
    skip
    call peek x
    if [[ "$x" == ")" ]]; then
        next _
        res="${VALNIL}"
    else
        call value x
        call list y
        new_val pair "$x" "$y" res
    fi

    $returns res
}
value () {
    local x res

    call token x
    case "${x:0:1}" in
        "(")
            call list res;;
        "#")
            new_val "bool" "$x" _ res
            ;;
        '`')
            call value x
            new_val "quote" "$x" _ res
            ;;
        *)
            if [[ "$x" =~ ^-?[0-9]+$ ]]; then
                new_val "int" "$x" _ res
            else
                new_val "symbol" "$x" _ res
            fi;;
    esac

    $returns res
}
ENVNIL="-1"
ENVARENA=()
define new_env
_new_env () {
    local i="${#ENVARENA[@]}" next="$1" symbol="$2" value="$3"
    shift 3
    ENVARENA[$i]="$next"
    ENVARENA[$(( $i + 1 ))]="$symbol"
    ENVARENA[$(( $i + 2 ))]="$value"

    $returns i
}
envdestruct () {
    local e="$1"
    shift 1
    eval "
        $1='${ENVARENA[$e]}'
        $2='${ENVARENA[$(( $e + 1 ))]}'
        $3='${ENVARENA[$(( $e + 2 ))]}'
    " || die "envsectruct"
}
lookup () {
    local e="$1" s="$2" res next symbol value
    shift 2
    [[ $e == $ENVNIL ]] && die "not found: '$s'"

    call3 envdestruct $e next symbol value
    if [[ "$symbol" == "$s" ]]; then
        res=$value
    else
        call lookup "$next" "$s" res
    fi
    $returns res
}
define eval1
_eval1 () {
    local e="$1" v="$2"
    shift 2

    eval2 $e $v _ res
    $returns res
}
define2 eval2
_eval2 () {
    local e="$1" v="$2" v_kind v_first v_second u retenv retval
    shift 2
    valdestruct $v v_kind v_first v_second
    case "$v_kind" in
        "nil" | "bool" | "int")
            retenv="$e"
            retval="$v" ;;
        "quote")
            retenv="$e"
            retval="$v_first" ;;
        "pair")
            eval1 "$e" "$v_first" u
            must_func "$u" fun
            eval call2 "'$fun'" "'$e'" "'$v_second'" retenv retval || die ;;
        "symbol")
            call lookup "$e" "$v_first" retval
            retenv="$e";;
    esac

    $returns retenv retval
}
define evaluate_list
_evaluate_list () {
    local e=$1 v=$2 v_kind v_first v_second v_second_kind res
    shift 2
    valdestruct "$v" v_kind v_first v_second
    eval2 "$e" "$v_first" e res
    valdestruct "$v_second" v_second_kind _ _
    if [[ $v_second_kind == "nil" ]]; then
        :
    else
        evaluate_list "$e" "$v_second" res
    fi
    $returns res
}
define2 op_1
_op_1 () {
    local f=$1 e=$2 v=$3 v_first res x
    shift 3

    must_pair $v v_first _
    eval1 $e $v_first x

    call "$f" "$x" res

    $returns e res
}
define2 op_2
_op_2 () {
    local f=$1 e=$2 v=$3 v_first v_second v_second_first x y res
    shift 3

    must_pair $v v_first v_second
    must_pair $v_second v_second_first _


    eval1 $e $v_first x
    eval1 $e $v_second_first y

    call "$f" "$x" "$y" res

    $returns e res
}

define2 op_fold
_op_fold () {
    local f=$1 e=$2 v=$3 v_first v_second v_second_kind x y
    shift 3

    valdestruct $v _ v_first v_second
    valdestruct $v_second v_second_kind _ _
    eval1 $e $v_first x
    if [[ $v_second_kind == "nil" ]]; then
        :
    else
        op_fold $f $e $v_second e y
        valdestruct $x _ x _
        valdestruct $y _ y _
        call $f "$x" "$y" x
    fi
    $returns e x
}
do_print () {
    valshow "$1"
    shift
    $returns VALNIL
}
func_print () { op_1 do_print "$@"; }
func_begin () {
    local e=$1 v=$2 retval
    shift 2
    evaluate_list $e $v retval
    $returns e retval
}
do_equals () {
    local x y v
    must_int $1 x
    must_int $2 y
    shift 2
    new_bool $(( $x == $y )) v
    $returns v
}
func_equals () { op_2 do_equals "$@"; }
do_sub () {
    local x y v
    must_int $1 x
    must_int $2 y
    shift 2
    new_int $(( $x - $y )) v
    $returns v
}
func_sub () { op_2 do_sub "$@"; }
do_div () {
    local x y v
    valdestruct $1 _ x _
    valdestruct $2 _ y _
    shift 2
    new_int $(( $x / $y )) v
    $returns v
}
func_div () { op_2 do_div "$@"; }

do_add () {
    local v
    new_int $(( $1 + $2 )) v
    shift 2
    $returns v
}
func_add () { op_fold do_add "$@"; }

do_mul () {
    local v
    new_int $(( $1 * $2 )) v
    shift 2
    $returns v
}
func_mul () { op_fold do_mul "$@"; }

do_and () {
    local x=1 v
    [[ $1 == "#f" ]] || [[ $2 == "#f" ]] && x=0
    shift 2
    new_bool $x v
    $returns v
}
func_and () { op_fold do_and "$@"; }

do_or () {
    local x=1 v
    [[ $1 == "#f" ]] && [[ $2 == "#f" ]] && x=0
    shift 2
    new_bool $x v
    $returns v
}
func_or () { op_fold do_or "$@"; }
do_not () {
    local x res=0
    valdestruct $1 _ x _
    shift
    [[ "$x" == "#f" ]] && res=1
    new_bool $res res
    $returns res
}
func_not () { op_1 do_not "$@"; }
do_lt () {
    local x y v
    valdestruct $1 _ x _
    valdestruct $2 _ y _
    shift 2
    new_bool $(( $x < $y )) v
    $returns v
}
func_lt () { op_2 do_lt "$@"; }
do_le () {
    local x y v
    valdestruct $1 _ x _
    valdestruct $2 _ y _
    shift 2
    new_bool $(( $x <= $y )) v
    $returns v
}
func_le () { op_2 do_le "$@"; }
do_gt () {
    local x y v
    valdestruct $1 _ x _
    valdestruct $2 _ y _
    shift 2
    new_bool $(( $x > $y )) v
    $returns v
}
func_gt () { op_2 do_gt "$@"; }
do_ge () {
    local x y v
    valdestruct $1 _ x _
    valdestruct $2 _ y _
    shift 2
    new_bool $(( $x >= $y )) v
    $returns v
}
func_ge () { op_2 do_ge "$@"; }
do_cons () {
    local v
    new_pair $1 $2 v
    shift 2
    $returns v
}
func_cons () { op_2 do_cons "$@"; }
do_car () {
    local v
    must_pair $1 v _
    shift 1
    $returns v
}
func_car () { op_1 do_car "$@"; }
do_cdr () {
    local v
    must_pair $1 _ v
    shift 1
    $returns v
}
func_cdr () { op_1 do_cdr "$@"; }

with_func () { call _with_func "$@"; }
_with_func () {
    local e=$1 symbol="$2" fun=$3 x ne
    shift 3

    new_val "func" $fun _ x
    new_env "$e" "$symbol" "$x" ne
    $returns ne
}
default_env () {
    local e=$ENVNIL x

    with_func $e print func_print  e
    with_func $e begin func_begin  e
    with_func $e "="   func_equals e
    with_func $e "-"   func_sub    e
    with_func $e "/"   func_div    e
    with_func $e '*'   func_mul    e
    with_func $e "+"   func_add    e
    with_func $e and   func_and    e
    with_func $e or    func_or     e
    with_func $e not   func_not    e
    with_func $e "<"   func_lt     e
    with_func $e "<="  func_le     e
    with_func $e ">"   func_gt     e
    with_func $e ">="  func_ge     e
    with_func $e cons  func_cons   e
    with_func $e car   func_car    e
    with_func $e cdr   func_cdr    e

    $returns e
}
returns="eval sets \$1 \$2 \$3"
sets () {
    case $# in
        0) : ;;
        2) eval "$1=\"\${!2}\"" ;;
        4) eval "$1=\"\${!3}\"; $2=\"\${!4}\"" ;;
        6) eval "$1=\"\${!4}\"; $2=\"\${!5}\"; $3=\"\${!6}\"" ;;
        *) die "sets: invalid number of args $#" ;;
    esac
}
die () {
    log "$@: ${FUNCNAME[@]}" 1>&2
    exit 1
}
log () {
    echo "$@" 1>&2
}
main () {
    local e
    call default_env e

    local x
    call list x
    evaluate_list "$e" "$x" _
}

main
