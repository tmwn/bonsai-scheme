#!/bin/bash

: <<'COMMENT'
# Data structure

Arenas are used to store data in referenceable form.

Value arena is one dimentional array in the following form.

( type1 x1 y1 type2 x2 y2 ... )

Each three consecutive data represents one value. Any value appears in the
program is stored in the arena and always referenced by its index in the
value arena. 0 represents the first data, 3 does the second data, and so on.
A type is one of the following: nil, bool, int, pair, symbol, func, quote .
A value of each type has the following form.

- nil "" ""
- bool t ""
- int 100 ""
- pair 6 9
- symbol print ""
- func <func> ""
- quote 3 ""

<func> is a stringified bash script. It assumes two inputs $env and $val and
returns the resulting environment and value.

Env arena is one dimentional array in the following form. Any environment
appears in the program are referenced by its index in the env arena.

( next1 name1 value1 next2 name2 value2 ... )

name is a symbol string. next and value are pointers to the next item in the
linked list and the value for the symbol.

# Function calls
Using dynamic scope and eval, function return values can be emulated.
Functions typically end with eval to set return values. Example:
  add () {
    local a=$1 b=$2
    shift 2
    local res=$(( $a + $b ))
    eval "$1='$res'"
  }
  main () {
    local x
    add 1 2 x
    echo $x   # 3
  }
To use this technique, it's important that variables have unique names. In the
above example if we substitute a with x, the program will output nothing.
To ensure variable name uniqueness, a wrapper named call is used. call
generates unique id and use it in place of return values on calling wrapped
function, and forwards the results. call should be used whenever return values
are used. Example:
  fact () {
    local n=$1 res
    shift 1
    if [[ $n -eq 0 ]]; then
        res=1
    else
        call fact $(( $n - 1 )) res
        res=$(( $n * $res ))
    fi
    $returns res
  }
  call fact 10 res
  echo $res

Here, $returns is a shorthand for eval "$1='$res'".
COMMENT

declare code="$(cat $1))"

MAX_CALL=1000
call_index=0
call () {
    [[ $call_index -lt $MAX_CALL ]] || die "call_index >= $MAX_CALL"
    # use long name not to collide with return value names
    local call_variable_name="call_variable$(( call_index += 1 ))"
    local call_all_args=( "$@" )
    local call_real_name="${call_all_args[$(( $# - 1 ))]}"
    call_all_args[$(( $# - 1 ))]=$call_variable_name
    "${call_all_args[@]}"
    eval "$call_real_name='${!call_variable_name}'" || die "call"
}
call2 () {
    [[ $call_index -lt $MAX_CALL ]] || die "call_index >= $MAX_CALL"
    local call_variable_name1="call_variable$(( call_index += 1 ))"
    local call_variable_name2="call_variable$(( call_index += 1 ))"
    local call_all_args=( "$@" )
    local call_real_name1="${call_all_args[$(( $# - 2 ))]}"
    local call_real_name2="${call_all_args[$(( $# - 1 ))]}"
    call_all_args[$(( $# - 2 ))]=$call_variable_name1
    call_all_args[$(( $# - 1 ))]=$call_variable_name2
    "${call_all_args[@]}"
    eval "
        $call_real_name1='${!call_variable_name1}'
        $call_real_name2='${!call_variable_name2}'
    " || die "call2"
}
call3 () {
    [[ $call_index -lt $MAX_CALL ]] || die "call_index >= $MAX_CALL"
    local call_variable_name1="call_variable$(( call_index += 1 ))"
    local call_variable_name2="call_variable$(( call_index += 1 ))"
    local call_variable_name3="call_variable$(( call_index += 1 ))"
    local call_all_args=( "$@" )
    local call_real_name1="${call_all_args[$(( $# - 3 ))]}"
    local call_real_name2="${call_all_args[$(( $# - 2 ))]}"
    local call_real_name3="${call_all_args[$(( $# - 1 ))]}"
    call_all_args[$(( $# - 3 ))]=$call_variable_name1
    call_all_args[$(( $# - 2 ))]=$call_variable_name2
    call_all_args[$(( $# - 1 ))]=$call_variable_name3
    "${call_all_args[@]}"
    eval "
        $call_real_name1='${!call_variable_name1}'
        $call_real_name2='${!call_variable_name2}'
        $call_real_name3='${!call_variable_name3}'
    " || die "call3"
}

next () {
    local x

    call peek x
    code="${code:1}"

    $returns x
}
peek () {
    local x="${code:0:1}" 
    [[ $x == "'" ]] && x='`' # not to mess up eval
    $returns x
}
skip () {
    local x
    [[ -z "$code" ]] && return

    call peek x
    if [[ "$x" == " " ]] || [[ "$x" == $'\n' ]]; then
        next _
        skip
    fi
}
token () {
    local x y
    
    skip
    call next x
    case "$x" in
        "(" | ")" | '`')
            : ;;
        "#")
            call next x
            x="#${x}"
            ;;
        *)
            call peek y
            while [[ "$y" != ")" ]] && [[ "$y" != " " ]] && [[ "$y" != $'\n' ]]; do
                x="${x}${y}"

                call next _
                call peek y
            done
            ;;
    esac

    $returns x
}
VALARENA=("nil" "" "")
VALNIL=0
valalloc () {
    local kind="$1" first="$2" second="$3"
    shift 3
    local i=${#VALARENA[*]}
    VALARENA[$i]="$kind"
    VALARENA[$(( $i + 1 ))]="$first"
    VALARENA[$(( $i + 2 ))]="$second"

    $returns i
}
valdestruct () {
    local x=$1
    shift
    local kind="${VALARENA[$(( $x + 0 ))]}"
    local first="${VALARENA[$(( $x + 1 ))]}"
    local second="${VALARENA[$(( $x + 2 ))]}"

    $returns kind first second
}
valshow () {
    call3 valdestruct "$1" kind first secon
    case "$kind" in
        "nil")
            echo -n nil;;
        "bool")
            echo -n "#${first}";;
        "int")
            echo -n "${first}";;
        "pair")
            echo -n "( "
            local snd2="${second}"
            valshow "$first"
            echo -n " . "
            valshow "${snd2}"
            echo -n " )";;
        "quote")
            echo -n "'"
            valshow "$first" ;;
        "symbol")
            echo -n "$first";;
        "func")
            echo -n "<func>";;
    esac
}
list () {
    local x y res
    skip
    call peek x
    if [[ "$x" == ")" ]]; then
        next _
        res="${VALNIL}"
    else
        call value x
        call list y
        call valalloc pair "$x" "$y" res
    fi

    $returns res
}
value () {
    local x res

    call token x
    case "${x:0:1}" in
        "(")
            call list res;;
        "#")
            call valalloc "bool" "${x:1}" _ res
            ;;
        '`')
            call value x
            call valalloc "quote" "$x" _ res
            ;;
        *)
            if [[ "$x" =~ ^-?[0-9]+$ ]]; then
                call valalloc "int" "$r1" _ res
            else
                call valalloc "symbol" "$x" _ res
            fi;;
    esac

    $returns res
}
ENVNIL="-1"
ENVARENA=()
envalloc () {
    local i="${#ENVARENA[@]}" next="$1" symbol="$2" value="$3"
    shift 3
    ENVARENA[$i]="$next"
    ENVARENA[$(( $i + 1 ))]="$symbol"
    ENVARENA[$(( $i + 2 ))]="$value"

    $returns i
}
envdestruct () {
    local e="$1"
    shift 1
    eval "
        $1='${ENVARENA[$e]}'
        $2='${ENVARENA[$(( $e + 1 ))]}'
        $3='${ENVARENA[$(( $e + 2 ))]}'
    " || die "envsectruct"
}
lookup () {
    local e="$1" s="$2" res next symbol value
    shift 2
    [[ $e == $ENVNIL ]] && die "not found: '$s'"

    call3 envdestruct $e next symbol value
    if [[ "$symbol" == "$s" ]]; then
        res=$value
    else
        call lookup "$next" "$s" res
    fi
    $returns res
}
evaluate () {
    local e="$1" v="$2" v_kind v_first v_second u retenv retval
    shift 2
    call3 valdestruct $v v_kind v_first v_second
    case "$v_kind" in
        "nil" | "bool" | "int")
            retenv="$e"
            retval="$v" ;;
        "quote")
            retenv="$e"
            retval="$v_first" ;;
        "pair")
            call2 evaluate "$e" "$v_first" _ u
            call3 valdestruct "$u" _ fun _
            eval call2 "$fun" "'$e'" "'$v_second'" retenv retval || die "evaluate" ;;
        "symbol")
            call lookup "$e" "$v_first" retval
            retenv="$e";;
    esac

    $returns retenv retval
}
evaluatelist () {
    local e=$1 v=$2 v_kind v_first v_second v_second_kind res
    shift 2
    call3 valdestruct "$v" v_kind v_first v_second
    call2 evaluate "$e" "$v_first" e res
    call3 valdestruct "$v_second" v_second_kind _ _
    if [[ $v_second_kind == "nil" ]]; then
        :
    else
        call evaluatelist "$e" "$v_second" res
    fi
    $returns res
}
funcprint () {
    local e=$1 v=$2 kind first second retenv retval
    shift 2
    call3 valdestruct $v kind first second
    call2 evaluate $e $first retenv retval
    valshow $retval; echo

    $returns e VALNIL
}
funcbegin () {
    local e=$1 v=$2 retval
    shift 2
    call evaluatelist "$e" "$v" retval
    $returns e retval
}
newenv () {
    local e=$ENVNIL x

    call valalloc "func" funcprint _ x
    call envalloc "$e" print "$x" e

    call valalloc "func" funcbegin _ x
    call envalloc "$e" begin "$x" e

    $returns e
}
returns="eval sets \$1 \$2 \$3"
sets () {
    case $# in
        0) : ;;
        2) eval "$1=\"\${!2}\"" ;;
        4) eval "$1=\"\${!3}\"; $2=\"\${!4}\"" ;;
        6) eval "$1=\"\${!4}\"; $2=\"\${!5}\"; $3=\"\${!6}\"" ;;
        *) die "sets: invalid number of args $#" ;;
    esac
}
die () {
    log "$@: ${FUNCNAME[@]}" 1>&2
    exit 1
}
log () {
    echo "$@" 1>&2
}
main () {
    local e
    call newenv e

    local x
    call list x
    call evaluatelist "$e" "$x" _
}

main
