#!/bin/bash

: <<'COMMENT'
# Data structure

Arenas are used to store data in referenceable form.

Value arena is one dimentional array in the following form.

( type1 x1 y1 type2 x2 y2 ... )

Each three consecutive data represents one value. Any value appears in the
program is stored in the arena and always referenced by its index in the
value arena. 0 represents the first data, 3 does the second data, and so on.
A type is one of the following: nil, bool, int, pair, symbol, func, quote .
A value of each type has the following form.

- nil "" ""
- bool #t ""
- int 100 ""
- pair 6 9
- symbol print ""
- func <func> ""
- quote 3 ""

<func> is a stringified bash script. It assumes two inputs $env and $val and
returns the resulting environment and value.

Env arena is one dimentional array in the following form. Any environment
appears in the program are referenced by its index in the env arena.

( next1 name1 value1 next2 name2 value2 ... )

name is a symbol string. next and value are pointers to the next item in the
linked list and the value for the symbol.

# Function calls
Using dynamic scope and eval, function return values can be emulated.
Functions typically end with eval to set return values. Example:
  add () {
    local a=$1 b=$2
    shift 2
    local res=$(( $a + $b ))
    eval "$1='$res'"
  }
  main () {
    local x
    add 1 2 x
    echo $x   # 3
  }
To use this technique, it's important that variables have unique names. In the
above example if we substitute a with x, the program will output nothing.
To ensure variable name uniqueness, a wrapper named call is used. call
generates unique id and use it in place of return values on calling wrapped
function, and forwards the results. call should be used whenever return values
are used. Example:
  fact () {
    local n=$1 res
    shift 1
    if [[ $n -eq 0 ]]; then
        res=1
    else
        call fact $(( $n - 1 )) res
        res=$(( $n * $res ))
    fi
    $returns res
  }
  call fact 10 res
  echo $res

Here, $returns is a shorthand for eval "$1='$res'".
COMMENT

declare code="$(cat $1))"

MAX_CALL=5000
call_index=0
call () {
    [[ $call_index -lt $MAX_CALL ]] || die "call_index >= $MAX_CALL"
    # use long name not to collide with return value names
    local call_variable_name="call_variable$(( call_index += 1 ))"
    local call_all_args=( "$@" )
    local call_real_name="${call_all_args[$(( $# - 1 ))]}"
    call_all_args[$(( $# - 1 ))]=$call_variable_name
    "${call_all_args[@]}"
    eval "$call_real_name='${!call_variable_name}'" || die "call"
}
call2 () {
    [[ $call_index -lt $MAX_CALL ]] || die "call_index >= $MAX_CALL"
    local call_variable_name1="call_variable$(( call_index += 1 ))"
    local call_variable_name2="call_variable$(( call_index += 1 ))"
    local call_all_args=( "$@" )
    local call_real_name1="${call_all_args[$(( $# - 2 ))]}"
    local call_real_name2="${call_all_args[$(( $# - 1 ))]}"
    call_all_args[$(( $# - 2 ))]=$call_variable_name1
    call_all_args[$(( $# - 1 ))]=$call_variable_name2
    "${call_all_args[@]}"
    eval "
        $call_real_name1='${!call_variable_name1}'
        $call_real_name2='${!call_variable_name2}'
    " || die "call2"
}
call3 () {
    [[ $call_index -lt $MAX_CALL ]] || die "call_index >= $MAX_CALL"
    local call_variable_name1="call_variable$(( call_index += 1 ))"
    local call_variable_name2="call_variable$(( call_index += 1 ))"
    local call_variable_name3="call_variable$(( call_index += 1 ))"
    local call_all_args=( "$@" )
    local call_real_name1="${call_all_args[$(( $# - 3 ))]}"
    local call_real_name2="${call_all_args[$(( $# - 2 ))]}"
    local call_real_name3="${call_all_args[$(( $# - 1 ))]}"
    call_all_args[$(( $# - 3 ))]=$call_variable_name1
    call_all_args[$(( $# - 2 ))]=$call_variable_name2
    call_all_args[$(( $# - 1 ))]=$call_variable_name3
    "${call_all_args[@]}"
    eval "
        $call_real_name1='${!call_variable_name1}'
        $call_real_name2='${!call_variable_name2}'
        $call_real_name3='${!call_variable_name3}'
    " || die "call3"
}

next () {
    local x

    call peek x
    code="${code:1}"

    $returns x
}
peek () {
    local x="${code:0:1}" 
    [[ $x == "'" ]] && x='`' # not to mess up eval
    $returns x
}
skip () {
    local x
    [[ -z "$code" ]] && return

    call peek x
    if [[ "$x" == " " ]] || [[ "$x" == $'\n' ]]; then
        next _
        skip
    fi
}
token () {
    local x y
    
    skip
    call next x
    case "$x" in
        "(" | ")" | '`')
            : ;;
        "#")
            call next x
            x="#${x}"
            ;;
        *)
            call peek y
            while [[ "$y" != ")" ]] && [[ "$y" != " " ]] && [[ "$y" != $'\n' ]]; do
                x="${x}${y}"

                call next _
                call peek y
            done
            ;;
    esac

    $returns x
}

VALARENA=("nil" "" "")
VALNIL=0

define () { eval "$1 () { call _$1 \"\$@\"; }"; }

define new_val
_new_val () {
    local kind="$1" first="$2" second="$3"
    shift 3
    local i=${#VALARENA[*]}
    VALARENA[$i]="$kind"
    VALARENA[$(( $i + 1 ))]="$first"
    VALARENA[$(( $i + 2 ))]="$second"

    $returns i
}
new_bool () {
    if [[ $1 -ne 0 ]]; then
        new_val "bool" "#t" _ $2
    else
        new_val "bool" "#f" _ $2
    fi
}
new_int () {
    new_val "int" $1 _ $2
}
valdestruct () { call3 _valdestruct "$@"; }
_valdestruct () {
    local x=$1
    shift
    local kind="${VALARENA[$(( $x + 0 ))]}"
    local first="${VALARENA[$(( $x + 1 ))]}"
    local second="${VALARENA[$(( $x + 2 ))]}"

    $returns kind first second
}
valshow () {
    local nonewline="$2" kind first second
    valdestruct "$1" kind first second
    case "$kind" in
        "nil")
            echo -n nil;;
        "bool")
            echo -n "$first";;
        "int")
            echo -n "$first";;
        "pair")
            echo -n "( "
            valshow "$first" 1
            echo -n " . "
            valshow "$second" 1
            echo -n " )";;
        "quote")
            echo -n "'"
            valshow "$first" 1;;
        "symbol")
            echo -n "$first";;
        "func")
            echo -n "<func>";;
    esac
    [[ -z "$nonewline" ]] && echo
}
list () {
    local x y res
    skip
    call peek x
    if [[ "$x" == ")" ]]; then
        next _
        res="${VALNIL}"
    else
        call value x
        call list y
        new_val pair "$x" "$y" res
    fi

    $returns res
}
value () {
    local x res

    call token x
    case "${x:0:1}" in
        "(")
            call list res;;
        "#")
            new_val "bool" "$x" _ res
            ;;
        '`')
            call value x
            new_val "quote" "$x" _ res
            ;;
        *)
            if [[ "$x" =~ ^-?[0-9]+$ ]]; then
                new_val "int" "$x" _ res
            else
                new_val "symbol" "$x" _ res
            fi;;
    esac

    $returns res
}
ENVNIL="-1"
ENVARENA=()
new_env() { call _new_env "$@"; }
_new_env () {
    local i="${#ENVARENA[@]}" next="$1" symbol="$2" value="$3"
    shift 3
    ENVARENA[$i]="$next"
    ENVARENA[$(( $i + 1 ))]="$symbol"
    ENVARENA[$(( $i + 2 ))]="$value"

    $returns i
}
envdestruct () {
    local e="$1"
    shift 1
    eval "
        $1='${ENVARENA[$e]}'
        $2='${ENVARENA[$(( $e + 1 ))]}'
        $3='${ENVARENA[$(( $e + 2 ))]}'
    " || die "envsectruct"
}
lookup () {
    local e="$1" s="$2" res next symbol value
    shift 2
    [[ $e == $ENVNIL ]] && die "not found: '$s'"

    call3 envdestruct $e next symbol value
    if [[ "$symbol" == "$s" ]]; then
        res=$value
    else
        call lookup "$next" "$s" res
    fi
    $returns res
}
eval1 () { call _eval1 "$@"; }
_eval1 () {
    local e="$1" v="$2"
    shift 2

    eval2 $e $v _ res
    $returns res
}
eval2 () { call2 _eval2 "$@"; }
_eval2 () {
    local e="$1" v="$2" v_kind v_first v_second u retenv retval
    shift 2
    valdestruct $v v_kind v_first v_second
    case "$v_kind" in
        "nil" | "bool" | "int")
            retenv="$e"
            retval="$v" ;;
        "quote")
            retenv="$e"
            retval="$v_first" ;;
        "pair")
            eval1 "$e" "$v_first" u
            valdestruct "$u" kind fun _
            [[ $kind == "func" ]] || die "$kind"
            eval call2 "'$fun'" "'$e'" "'$v_second'" retenv retval || die ;;
        "symbol")
            call lookup "$e" "$v_first" retval
            retenv="$e";;
    esac

    $returns retenv retval
}
evaluate_list () { call _evaluate_list "$@"; }
_evaluate_list () {
    local e=$1 v=$2 v_kind v_first v_second v_second_kind res
    shift 2
    valdestruct "$v" v_kind v_first v_second
    eval2 "$e" "$v_first" e res
    valdestruct "$v_second" v_second_kind _ _
    if [[ $v_second_kind == "nil" ]]; then
        :
    else
        evaluate_list "$e" "$v_second" res
    fi
    $returns res
}
op_1 () {
    local f=$1 e=$2 v=$3 v_first x res
    shift 3

    valdestruct $v _ v_first _
    eval1 $e $v_first x
    valdestruct $x _ x _

    call "$f" "$x" res
    $returns e res
}
op_2 () {
    local f=$1 e=$2 v=$3 v_first v_second v_second_first x y res
    shift 3

    valdestruct $v _ v_first v_second
    valdestruct $v_second _ v_second_first _
    eval1 $e $v_first x
    eval1 $e $v_second_first y
    valdestruct $x _ x _
    valdestruct $y _ y _

    call "$f" "$x" "$y" res
    $returns e res
}

define op_fold
_op_fold () {
    local f=$1 e=$2 v=$3 v_first v_second v_second_kind x y
    shift 3

    valdestruct $v _ v_first v_second
    valdestruct $v_second v_second_kind _ _
    eval1 $e $v_first x
    if [[ $v_second_kind == "nil" ]]; then
        :
    else
        op_fold $f $e $v_second e y
        valdestruct $x _ x _
        valdestruct $y _ y _
        call $f "$x" "$y" x
    fi
    $returns e x
}
doprint () {
    echo "$1"
    shift
    $returns VALNIL
}
funcprint () { call2 op_1 doprint "$@"; }
funcbegin () {
    local e=$1 v=$2 retval
    shift 2
    evaluate_list $e $v retval
    $returns e retval
}
doequals () {
    local x=0 v
    [[ "$1" -eq "$2" ]] && x=1
    shift 2

    new_bool $x v
    $returns v
}
funcequals () { call2 op_2 doequals "$@"; }
dosub () {
    local x=$(( $1 - $2 )) v
    shift 2
    new_int $x v
    $returns v
}
funcsub () { call2 op_2 dosub "$@"; }
dodiv () {
    local x=$(( $1 / $2 )) v
    shift 2
    new_int $x v
    $returns v
}
funcdiv () { call2 op_2 dodiv "$@"; }

doadd () {
    local x=$(( $1 + $2 )) v
    shift 2
    new_int $x v
    $returns v
}
funcadd () { call2 op_fold doadd "$@"; }

domul () {
    local x=$(( $1 * $2 )) v
    shift 2
    new_int $x v
    $returns v
}
funcmul () { call2 op_fold domul "$@"; }

doand () {
    local x=0
    [[ $1 == "#t" ]] && [[ $2 == "#t" ]] && x=1
    shift 2
    new_bool $x v
    $returns v
}
funcand () { call2 op_fold doand "$@"; }

with_func () { call _with_func "$@"; }
_with_func () {
    local e=$1 symbol="$2" fun=$3 x ne
    shift 3

    new_val "func" $fun _ x
    new_env "$e" "$symbol" "$x" ne
    $returns ne
}
default_env () {
    local e=$ENVNIL x

    with_func $e print funcprint  e
    with_func $e begin funcbegin  e
    with_func $e "="   funcequals e
    with_func $e "-"   funcsub    e
    with_func $e "/"   funcdiv    e
    with_func $e '*'   funcmul    e
    with_func $e "+"   funcadd    e
    with_func $e "and" funcand    e

    $returns e
}
returns="eval sets \$1 \$2 \$3"
sets () {
    case $# in
        0) : ;;
        2) eval "$1=\"\${!2}\"" ;;
        4) eval "$1=\"\${!3}\"; $2=\"\${!4}\"" ;;
        6) eval "$1=\"\${!4}\"; $2=\"\${!5}\"; $3=\"\${!6}\"" ;;
        *) die "sets: invalid number of args $#" ;;
    esac
}
die () {
    log "$@: ${FUNCNAME[@]}" 1>&2
    exit 1
}
log () {
    echo "$@" 1>&2
}
main () {
    local e
    call default_env e

    local x
    call list x
    evaluate_list "$e" "$x" _
}

main
