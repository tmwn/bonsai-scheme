#!/bin/bash

: <<'COMMENT'
# Data structure

Arenas are used to store data in referenceable form.

Value arena is one dimentional array in the following form.

( type1 x1 y1 type2 x2 y2 ... )

Each three consecutive data represents one value. Any value appears in the
program is stored in the arena and always referenced by its index in the
value arena. 0 represents the first data, 3 does the second data, and so on.
A type is one of the following: nil, bool, int, pair, symbol, func, quote .
A value of each type has the following form.

- nil "" ""
- bool t ""
- int 100 ""
- pair 6 9
- symbol print ""
- func <func> ""
- quote 3 ""

<func> is a stringified bash script. It assumes two inputs $env and $val and
returns the resulting environment and value.

Env arena is one dimentional array in the following form. Any environment
appears in the program are referenced by its index in the env arena.

( next1 name1 value1 next2 name2 value2 ... )

name is a symbol string. next and value are pointers to the next item in the
linked list and the value for the symbol.

# Function calls
Using dynamic scope and eval, function return values can be emulated.
Functions typically end with eval to set return values. Example:
  add () {
    local a=$1 b=$2
    shift 2
    local res=$(( $a + $b ))
    eval "$1='$res'"
  }
  main () {
    local x
    add 1 2 x
    echo $x   # 3
  }
To use this technique, it's important that variables have unique names. In the
above example if we substitute a with x, the program will output nothing.
To ensure variable name uniqueness, a wrapper named call is used. call
generates unique id and use it in place of return values on calling wrapped
function, and forwards the results. call should be used whenever return values
are used. Example:
  fact () {
    local n=$1 res
    shift 1
    if [[ $n -eq 0 ]]; then
        res=1
    else
        call fact $(( $n - 1 )) res
        res=$(( $n * $res ))
    fi
    eval "$1='$res'"
  }
  call fact 10 res
  echo $res
COMMENT

declare r1 r2 r3          # general return values
declare kind first second # valdestruct return values
declare retenv retval     # evaluation return values

declare code="$(cat $1))"

MAX_CALL=1000
call_index=0
call () {
    [[ $call_index -lt $MAX_CALL ]] || die "call_index >= $MAX_CALL"
    # use long name not to collide with return value names
    local call_variable_name="call_variable$(( call_index += 1 ))"
    local call_all_args=( "$@" )
    local call_real_name="${call_all_args[$(( $# - 1 ))]}"
    call_all_args[$(( $# - 1 ))]=$call_variable_name
    "${call_all_args[@]}"
    eval "$call_real_name='${!call_variable_name}'" || die "call"
}
call2 () {
    [[ $call_index -lt $MAX_CALL ]] || die "call_index >= $MAX_CALL"
    local call_variable_name1="call_variable$(( call_index += 1 ))"
    local call_variable_name2="call_variable$(( call_index += 1 ))"
    local call_all_args=( "$@" )
    local call_real_name1="${call_all_args[$(( $# - 2 ))]}"
    local call_real_name2="${call_all_args[$(( $# - 1 ))]}"
    call_all_args[$(( $# - 2 ))]=$call_variable_name1
    call_all_args[$(( $# - 1 ))]=$call_variable_name2
    "${call_all_args[@]}"
    eval "
        $call_real_name1='${!call_variable_name1}'
        $call_real_name2='${!call_variable_name2}'
    " || die "call2"
}
call3 () {
    [[ $call_index -lt $MAX_CALL ]] || die "call_index >= $MAX_CALL"
    local call_variable_name1="call_variable$(( call_index += 1 ))"
    local call_variable_name2="call_variable$(( call_index += 1 ))"
    local call_variable_name3="call_variable$(( call_index += 1 ))"
    local call_all_args=( "$@" )
    local call_real_name1="${call_all_args[$(( $# - 3 ))]}"
    local call_real_name2="${call_all_args[$(( $# - 2 ))]}"
    local call_real_name3="${call_all_args[$(( $# - 1 ))]}"
    call_all_args[$(( $# - 3 ))]=$call_variable_name1
    call_all_args[$(( $# - 2 ))]=$call_variable_name2
    call_all_args[$(( $# - 1 ))]=$call_variable_name3
    "${call_all_args[@]}"
    eval "
        $call_real_name1='${!call_variable_name1}'
        $call_real_name2='${!call_variable_name2}'
        $call_real_name3='${!call_variable_name3}'
    " || die "call3"
}

next () {
    local x

    call peek x
    code="${code:1}"

    eval "$1='$x'"
}
peek () {
    local x="${code:0:1}" 
    [[ $x == "'" ]] && x='`' # not to mess up eval
    eval "$1='$x'"
}
skip () {
    local x
    [[ -z "$code" ]] && return

    call peek x
    if [[ "$x" == " " ]] || [[ "$x" == $'\n' ]]; then
        next _
        skip
    fi
}
token () {
    local x y
    
    skip
    call next x
    case "$x" in
        "(" | ")" | '`')
            : ;;
        "#")
            call next x
            x="#${x}"
            ;;
        *)
            call peek y
            while [[ "$y" != ")" ]] && [[ "$y" != " " ]] && ! [[ "$y" == $'\n' ]]; do
                x="${x}${y}"
                next _
                call peek y
            done
            ;;
    esac

    eval "$1='$x'"
}
VALARENA=("nil" "" "")
VALNIL=0
valalloc () {
    local kind="$1" first="$2" second="$3"
    shift 3
    local i=${#VALARENA[*]}
    VALARENA[$i]="$kind"
    VALARENA[$(( $i + 1 ))]="$first"
    VALARENA[$(( $i + 2 ))]="$second"

    eval "$1='$i'" || die "valalloc"
}
valdestruct () {
    local x=$1
    shift
    local kind="${VALARENA[$(( $x + 0 ))]}"
    local first="${VALARENA[$(( $x + 1 ))]}"
    local second="${VALARENA[$(( $x + 2 ))]}"

    eval "$1='$kind'; $2='$first'; $3='$second'" || die "valdestruct"
}
valshow () {
    call3 valdestruct "$1" kind first secon
    case "$kind" in
        "nil")
            echo -n nil;;
        "bool")
            echo -n "#${first}";;
        "int")
            echo -n "${first}";;
        "pair")
            echo -n "( "
            local snd2="${second}"
            valshow "$first"
            echo -n " . "
            valshow "${snd2}"
            echo -n " )";;
        "quote")
            echo -n "'"
            valshow "$first" ;;
        "symbol")
            echo -n "$first";;
    esac
}
list () {
    local x y res
    skip
    call peek x
    if [[ "$x" == ")" ]]; then
        next _
        res="${VALNIL}"
    else
        call value x
        call list y
        call valalloc pair "$x" "$y" res
    fi

    eval "$1='$res'" || die "list"
}
value () {
    local x res

    call token x
    case "${x:0:1}" in
        "(")
            call list res;;
        "#")
            call valalloc "bool" "${x:1}" _ res
            ;;
        '`')
            call value x
            call valalloc "quote" "$x" _ res
            ;;
        *)
            if [[ "$x" =~ ^-?[0-9]+$ ]]; then
                call valalloc "int" "$r1" _ res
            else
                call valalloc "symbol" "$x" _ res
            fi;;
    esac

    eval "$1='$res'"
}
ENVNIL="-1"
ENVARENA=()
envalloc () {
    r1="${#ENVARENA[*]}"
    ENVARENA[$r1]="$1"
    ENVARENA[$(( $r1 + 1 ))]="$2"
    ENVARENA[$(( $r1 + 2 ))]="$3"
}
envdestruct () {
    local x="$1"
    shift 1
    eval "
        $1='${ENVARENA[$x]}'
        $2='${ENVARENA[$(( $x + 1 ))]}'
        $3='${ENVARENA[$(( $x + 2 ))]}'
    "
}
lookup () {
    local e="$1" s="$2" res next symbol value
    shift 2
    [[ $e == $ENVNIL ]] && die "not found: '$s'"

    call3 envdestruct $e next symbol value
    if [[ "$symbol" == "$s" ]]; then
        res=$value
    else 
        call lookup "$next" "$s" res
    fi
    eval "$1='$res'"
}
evaluate () {
    local e="$1" v="$2" v_kind v_first v_second u retenv retval
    shift 2
    call3 valdestruct $v v_kind v_first v_second
    case "$v_kind" in
        "nil" | "bool" | "int")
            retenv="$e"
            retval="$v" ;;
        "quote")
            retenv="$e"
            retval="$v_first" ;;
        "pair")
            call2 evaluate "$e" "$v_first" _ u
            call3 valdestruct "$u" _ fun _
            eval "$fun" "$e" "$v_second";;
        "symbol")
            call lookup "$e" "$v_first" retval
            retenv="$e";;
    esac

    eval "$1='$retenv'; $2='$retval'"
}
evaluatelist () {
    local e=$1 v=$2 v_kind v_first v_second v_second_kind res
    shift 2
    call3 valdestruct "$v" v_kind v_first v_second
    call2 evaluate "$e" "$v_first" e res
    call3 valdestruct "$v_second" v_second_kind _ _
    if [[ $v_second_kind == "nil" ]]; then
        :
    else
        call evaluatelist "$e" "$v_second" res
    fi
    eval "$1='$res'" || die "evaluatelist"
}
funcprint () {
    local e=$1 v=$2
    call3 valdestruct $v kind first second
    call2 evaluate $e $first retenv retval
    valshow $retval; echo

    retenv=$e
    retval=${VALNIL}
}
funcbegin () {
    call evaluatelist "$1" "$2" retval
    retenv=$1
}
newenv () {
    local e=$ENVNIL

    call valalloc "func" funcprint _ r1
    envalloc $e "print" "$r1"; e=$r1

    call valalloc "func" funcbegin _ r1
    envalloc $e "begin" "$r1"; e=$r1
}
die () {
    echo "die: $1" 1>&2
    exit 1
}
main () {
    newenv
    local e="${r1}"

    local x
    call list x

    call evaluatelist "$e" "$x" _
}

main
