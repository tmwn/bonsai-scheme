#!/bin/bash

: <<'COMMENT'
# Data structure

Arenas are used to store data in referenceable form.

Value arena is one dimentional array in the following form.

( type1 x1 y1 type2 x2 y2 ... )

Each three consecutive data represents one value. Any value appears in the
program is stored in the arena and always referenced by its index in the
value arena. 0 represents the first data, 3 does the second data, and so on.
A type is one of the following: nil, bool, int, pair, symbol, func, quote .
A value of each type has the following form.

- nil "" ""
- bool t ""
- int 100 ""
- pair 6 9
- symbol print ""
- func <func> ""
- quote 3 ""

<func> is a stringified bash script. It assumes two inputs $env and $val and
returns the resulting environment and value.

Env arena is one dimentional array in the following form. Any environment
appears in the program are referenced by its index in the env arena.

( next1 name1 value1 next2 name2 value2 ... )

name is a symbol string. next and value are pointers to the next item in the
linked list and the value for the symbol.
COMMENT

declare r1 r2 r3          # general return values
declare kind first second # valdestruct return values
declare retenv retval     # evaluation return values

declare code="$(cat $1))"

next () {
    peek
    code="${code:1}"
}
peek () {
    r1="${code:0:1}"
}
skip () {
    [[ -z "$code" ]] && return
    peek
    if [[ "$r1" == " " ]] || [[ "$r1" == $'\n' ]]; then
        next
        skip
    fi
}
token () {
    skip
    next
    case "$r1" in
        "(" | ")" | "'")
            return ;;
        "#")
            next
            r1="#${r1}"
            return ;;
    esac
    local s="${r1}"
    peek
    while [[ "$r1" != ")" ]] && [[ "$r1" != " " ]] && ! [[ "$r1" == $'\n' ]]; do
        s="${s}${r1}"
        next
        peek
    done
    r1="${s}"
}
VALARENA=("nil" "" "")
VALNIL=0
valalloc () {
    r1="${#VALARENA[*]}"
    VALARENA[$r1]="$1"
    VALARENA[$(( $r1 + 1 ))]="$2"
    VALARENA[$(( $r1 + 2 ))]="$3"
}
valdestruct () {
    kind="${VALARENA[$(( $1 + 0 ))]}"
    first="${VALARENA[$(( $1 + 1 ))]}"
    second="${VALARENA[$(( $1 + 2 ))]}"
}
valshow () {
    valdestruct "$1"
    case "$kind" in
        "nil")
            echo -n nil;;
        "bool")
            echo -n "#${first}";;
        "int")
            echo -n "${first}";;
        "pair")
            echo -n "( "
            local snd2="${second}"
            valshow "$first"
            echo -n " . "
            valshow "${snd2}"
            echo -n " )";;
        "quote")
            echo -n "'"
            valshow "$first" ;;
        "symbol")
            echo -n "$first";;
    esac
}
list () {
    skip
    peek
    if [[ "$r1" == ")" ]]; then
        next
        r1="${VALNIL}"
        return
    fi
    value
    local v="$r1"
    list
    local l="$r1"
    valalloc pair "$v" "$l"
}
value () {
    token
    case "${r1:0:1}" in
        "(")
            list
            return ;;
        "#")
            valalloc "bool" "${r1:1}"
            return ;;
        "'")
            value
            valalloc "quote" "$r1"
            return ;;
    esac
    if [[ "$r1" =~ ^-?[0-9]+$ ]]; then
        valalloc "int" "$r1"
        return
    fi
    valalloc "symbol" "$r1"
}
ENVNIL="-1"
ENVARENA=()
envalloc () {
    r1="${#ENVARENA[*]}"
    ENVARENA[$r1]="$1"
    ENVARENA[$(( $r1 + 1 ))]="$2"
    ENVARENA[$(( $r1 + 2 ))]="$3"
}
envnext () {
    local e="$1"
    r1="${ENVARENA[$e]}"
}
envsymbol () {
    local e="$1"
    r1="${ENVARENA[$(( $e + 1 ))]}"
}
envvalue () {
    local e="$1"
    r1="${ENVARENA[$(( $e + 2 ))]}"
}
lookup () {
    local e="$1" s="$2"
    [[ $e == $ENVNIL ]] && die "not found: '$s'"

    envsymbol "$e"
    if [[ "$r1" == "$s" ]]; then
        envvalue "$e"
        return
    fi
    envnext "$e"
    lookup "$r1" "$s"
}
evaluate () {
    local e="$1"
    valdestruct "$2"
    case "$kind" in
        "nil" | "bool" | "int")
            retenv="$1"
            retval="$2" ;;
        "quote")
            valalloc "quote" "$first"
            retval="$r1"
            retenv="$e" ;;
        "pair")
            local sec=${second}
            evaluate "$e" "$first"
            valdestruct "$retval"
            eval "$first" "$retenv" "$sec";;
        "symbol")
            lookup "$e" "$first"
            retval="$r1"
            retenv="$e" ;;
    esac
}
evaluatelist () {
    local e=$1
    valdestruct $2
    local sec=$second

    evaluate $e $first

    valdestruct $sec
    [[ $kind == "nil" ]] && return
    evaluatelist $retenv $sec
}
funcprint () {
    local e=$1 v=$2
    valdestruct $v
    evaluate $e $first
    valshow $retval; echo

    retenv=$e
    retval=${VALNIL}
}
funcbegin () {
    evaluatelist "$1" "$2"
    retenv=$1
}
newenv () {
    local e=$ENVNIL

    valalloc "func" funcprint
    envalloc $e "print" "$r1"; e=$r1

    valalloc "func" funcbegin
    envalloc $e "begin" "$r1"; e=$r1
}
die () {
    echo "$1" 1>&2
    exit 1
}
main () {
    newenv
    local e="${r1}"
    list
    evaluatelist "$e" "$r1"
}

main
